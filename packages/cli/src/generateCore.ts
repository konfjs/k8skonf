import { log } from 'node:console';
import * as fs from 'node:fs';
import * as path from 'node:path';
import pc from 'picocolors';
import {
    type ClassDeclaration,
    type ConstructorDeclarationStructure,
    IndentationText,
    type InterfaceDeclarationStructure,
    Project,
    type PropertySignatureStructure,
    QuoteKind,
    type SourceFile,
    StructureKind,
    SyntaxKind,
} from 'ts-morph';
import type { Schemas } from './parseSchemas.ts';
import { removeUnusedFiles } from './utils.ts';

function cleanupDefaultClass(
    sourceFile: SourceFile,
    classDeclaration: ClassDeclaration,
    className: string,
) {
    sourceFile.getImportDeclaration('../http/http.ts')?.remove();
    sourceFile.getImportDeclaration(`../models/${className}Status.ts`)?.remove();
    classDeclaration.getProperty("'status'")?.remove();
    classDeclaration.getConstructors()[0]?.remove();
    classDeclaration.getStaticMember('discriminator')?.remove();
    classDeclaration.getStaticMember('mapping')?.remove();
    classDeclaration.getStaticMember('attributeTypeMap')?.remove();
    classDeclaration.getStaticMethod('getAttributeTypeMap')?.remove();

    for (const importDeclaration of sourceFile.getImportDeclarations()) {
        const updatedImport = importDeclaration.getModuleSpecifierValue().replace('./models', '');
        importDeclaration.setModuleSpecifier(updatedImport);
    }

    if (className === 'IoK8sApimachineryPkgApisMetaV1ObjectMeta') {
        sourceFile
            .getImportDeclaration(`./IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry.ts`)
            ?.remove();
        classDeclaration.getProperty("'creationTimestamp'")?.remove();
        classDeclaration.getProperty("'deletionGracePeriodSeconds'")?.remove();
        classDeclaration.getProperty("'deletionTimestamp'")?.remove();
        classDeclaration.getProperty("'generation'")?.remove();
        classDeclaration.getProperty("'managedFields'")?.remove();
        classDeclaration.getProperty("'resourceVersion'")?.remove();
        classDeclaration.getProperty("'selfLink'")?.remove();
        classDeclaration.getProperty("'uid'")?.remove();
        /**
         * ObjectMeta class is considered as cluster-scoped.
         * NamespacedObjectMeta will be used for namespaced resources.
         */
        classDeclaration.getProperty("'namespace'")?.remove();
    }

    /**
     * Generated code has single quotes around property names.
     * ts-morph doesn't handle quotes in properties.
     */
    for (const prop of classDeclaration.getProperties()) {
        const text = prop.getText();
        prop.replaceWithText(text.replaceAll("'", ''));
    }
}

function removeAutogeneratedComments(sourceFile: SourceFile) {
    const comments = sourceFile.getChildAtIndex(0).getLeadingCommentRanges();
    if (comments[0]) {
        const start = comments[0].getPos();
        const end = comments[0].getEnd();
        sourceFile.replaceText([start, end], '');
    }
}

function replaceRefs(sourceFile: SourceFile) {
    const t = sourceFile.getTypeAlias(sourceFile.getBaseNameWithoutExtension());
    for (const node of t?.findReferencesAsNodes() || []) {
        const srcFile = node.getSourceFile();
        const srcFileName = srcFile.getBaseName();
        const typeRef = node.getFirstAncestorByKind(SyntaxKind.TypeReference);
        const importRef = srcFile.getImportDeclaration(`../models/${sourceFile.getBaseName()}`);
        if (typeRef) {
            log(
                `${pc.cyan(srcFileName)}: Replacing ${pc.gray(typeRef.getText())} with ${pc.yellowBright('number | string')}`,
            );
            typeRef.replaceWithText('number | string');
        }
        if (importRef) {
            log(`${pc.cyan(srcFileName)}: Removing ${pc.gray(importRef.getText())}`);
            importRef.remove();
        }
    }
    sourceFile.delete();
}

function fixNumberStringTypes(project: Project, modelsPath: string) {
    const quantityFile = project.getSourceFile(
        path.join(modelsPath, 'IoK8sApimachineryPkgApiResourceQuantity.ts'),
    );
    const intOrStringFile = project.getSourceFile(
        path.join(modelsPath, 'IoK8sApimachineryPkgUtilIntstrIntOrString.ts'),
    );

    if (quantityFile) {
        replaceRefs(quantityFile);
    }

    if (intOrStringFile) {
        replaceRefs(intOrStringFile);
    }
}

function main() {
    const corePath = path.join(import.meta.dirname, '../../core');
    const modelsPath = path.join(corePath, 'src/models');
    /**
     * Remove some obvious unused files.
     * They're mostly intended to be used programmatically.
     * Note: Is there a better way to do this?
     */
    removeUnusedFiles(modelsPath);

    const project = new Project({
        tsConfigFilePath: path.join(corePath, 'tsconfig.json'),
        manipulationSettings: {
            indentationText: IndentationText.TwoSpaces,
            quoteKind: QuoteKind.Double,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,
            useTrailingCommas: true,
        },
    });
    /**
     * Replace ResourceQuantity and IntOrString with `number | string`.
     */
    fixNumberStringTypes(project, modelsPath);

    const schemas: Schemas = JSON.parse(
        fs.readFileSync(path.join(import.meta.dirname, '../schemas.json'), 'utf-8'),
    );

    for (const sourceFile of project.getSourceFiles()) {
        /**
         * Only process files in the src/models directory.
         */
        if (sourceFile.getDirectoryPath().startsWith(modelsPath)) {
            removeAutogeneratedComments(sourceFile);
            /**
             * openapi-generator generates one class per file.
             */
            const classDeclaration = sourceFile.getClasses()[0];
            const className = classDeclaration?.getName();
            if (classDeclaration && className) {
                log(`Processing ${pc.cyan(sourceFile.getBaseName())}`);
                /**
                 * Clean up the default generated class structure.
                 */
                cleanupDefaultClass(sourceFile, classDeclaration, className);
                if (schemas.classes[className]) {
                    const apiVersionProperty = classDeclaration.getProperty('apiVersion');
                    if (apiVersionProperty) {
                        const group = schemas.classes[className].group;
                        const version = schemas.classes[className].version;
                        /**
                         * Kubernetes core API group has no group prefix.
                         */
                        const groupVersion = group ? `${group}/${version}` : version;
                        apiVersionProperty.setInitializer(`'${groupVersion}'`);
                        apiVersionProperty.removeType();
                        apiVersionProperty.setIsReadonly(true);
                        apiVersionProperty.setHasQuestionToken(false);
                    }
                    const kindProperty = classDeclaration.getProperty('kind');
                    if (kindProperty) {
                        kindProperty.setInitializer(`'${schemas.classes[className].kind}'`);
                        kindProperty.removeType();
                        kindProperty.setIsReadonly(true);
                        kindProperty.setHasQuestionToken(false);
                    }
                    sourceFile.addImportDeclaration({
                        moduleSpecifier: '../K8sApp.ts',
                        namedImports: ['K8sApp'],
                    });

                    const interfaceProps: PropertySignatureStructure[] = [];
                    const i: InterfaceDeclarationStructure = {
                        kind: StructureKind.Interface,
                        name: `${schemas.classes[className].kind}Args`,
                        isExported: true,
                        properties: interfaceProps,
                    };

                    const c: ConstructorDeclarationStructure = {
                        kind: StructureKind.Constructor,
                        parameters: [
                            {
                                name: 'app',
                                type: 'K8sApp',
                            },
                            {
                                name: 'name',
                                type: 'string',
                            },
                            {
                                name: 'args',
                                type: `${schemas.classes[className].kind}Args`,
                            },
                        ],
                    };

                    const preferredOrder = ['apiVersion', 'kind', 'metadata', 'spec'];
                    const orderedProps = classDeclaration.getProperties().sort((a, b) => {
                        const aIndex = preferredOrder.indexOf(a.getName());
                        const bIndex = preferredOrder.indexOf(b.getName());
                        if (aIndex === -1 && bIndex === -1) return 0;
                        if (aIndex === -1) return 1;
                        if (bIndex === -1) return -1;
                        return aIndex - bIndex;
                    });

                    c.statements = [];
                    c.statements.push('super(args.metadata?.name || name);');
                    for (const [i, prop] of orderedProps.entries()) {
                        prop.setIsReadonly(true);
                        classDeclaration.getProperty(prop.getName())?.setOrder(i);
                        const interfaceProp: PropertySignatureStructure = {
                            kind: StructureKind.PropertySignature,
                            name: prop.getName(),
                            type: prop.getTypeNode()?.getText(),
                            hasQuestionToken: prop.hasQuestionToken(),
                            isReadonly: true,
                        };
                        if (prop.getName() === 'apiVersion' || prop.getName() === 'kind') {
                            continue;
                        }
                        if (prop.getName() === 'metadata') {
                            interfaceProp.hasQuestionToken = true;
                            c.statements.push('this.metadata = {');
                            c.statements.push('  name: args.metadata?.name || name,');
                            c.statements.push('  ...args.metadata,');
                            c.statements.push('};');
                            prop.setHasQuestionToken(false);
                            if (schemas.classes[className].namespaced) {
                                classDeclaration.setExtends('NamespacedApiObject');
                                prop.setType('NamespacedObjectMeta');
                                sourceFile.addImportDeclaration({
                                    moduleSpecifier: '../ApiObject.ts',
                                    namedImports: ['NamespacedObjectMeta', 'NamespacedApiObject'],
                                });
                                interfaceProp.type = 'NamespacedObjectMeta';
                                sourceFile
                                    .getImportDeclaration(
                                        '../models/IoK8sApimachineryPkgApisMetaV1ObjectMeta.ts',
                                    )
                                    ?.remove();
                            } else {
                                classDeclaration.setExtends('ApiObject');
                                sourceFile.addImportDeclaration({
                                    moduleSpecifier: '../ApiObject.ts',
                                    namedImports: ['ApiObject'],
                                });
                                interfaceProp.type = 'ObjectMeta';
                            }
                        } else {
                            c.statements.push(`this.${prop.getName()} = args.${prop.getName()};`);
                        }
                        interfaceProps.push(interfaceProp);
                    }
                    sourceFile.insertInterface(classDeclaration.getChildIndex(), i);
                    c.statements.push('app.addResource(this);');
                    classDeclaration.addConstructor(c);
                    classDeclaration.rename(schemas.classes[className].kind);
                } else if (schemas.interfaces[className]) {
                    classDeclaration.rename(schemas.interfaces[className].kind);

                    const i: InterfaceDeclarationStructure = {
                        kind: StructureKind.Interface,
                        name: schemas.interfaces[className].kind,
                        isExported: true,
                        docs: [
                            {
                                kind: StructureKind.JSDoc,
                                description: `\n${classDeclaration
                                    .getJsDocs()
                                    .map((doc) => doc.getInnerText())}`,
                            },
                        ],
                        properties: classDeclaration.getProperties().map((prop) => {
                            return {
                                name: prop.getName(),
                                type: prop.getTypeNode()?.getText(),
                                hasQuestionToken: prop.hasQuestionToken(),
                                isReadonly: prop.isReadonly(),
                                docs: [
                                    {
                                        kind: StructureKind.JSDoc,
                                        description: `\n${prop.getJsDocs().map((doc) => {
                                            return doc.getInnerText();
                                        })}`,
                                    },
                                ],
                            };
                        }),
                    };
                    classDeclaration.remove();
                    sourceFile.addInterface(i);
                }
            }
        }
    }

    project.saveSync();
}

main();
