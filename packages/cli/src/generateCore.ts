import { log } from 'node:console';
import * as fs from 'node:fs';
import * as path from 'node:path';
import pc from 'picocolors';
import {
    ClassDeclaration,
    ConstructorDeclarationStructure,
    IndentationText,
    InterfaceDeclarationStructure,
    Project,
    PropertySignatureStructure,
    QuoteKind,
    SourceFile,
    StatementStructures,
    StructureKind,
    SyntaxKind,
} from 'ts-morph';
import type { Schemas } from './parseSchemas.ts';
import { formatCode, removeUnusedFiles } from './utils.ts';

function removeUnusedThings(
    sourceFile: SourceFile,
    classDeclaration: ClassDeclaration,
    className: string,
) {
    sourceFile.getImportDeclaration('../http/http.js')?.remove();
    sourceFile.getImportDeclaration(`../models/${className}Status.js`)?.remove();
    sourceFile
        .getImportDeclaration('../models/IoK8sApiAuthorizationV1SubjectAccessReviewStatus.js')
        ?.remove();
    sourceFile
        .getImportDeclaration('../models/IoK8sApiAuthorizationV1SubjectRulesReviewStatus.js')
        ?.remove();
    sourceFile
        .getImportDeclaration('../models/IoK8sApimachineryPkgApiResourceQuantity.js')
        ?.remove();
    sourceFile
        .getImportDeclaration('../models/IoK8sApimachineryPkgUtilIntstrIntOrString.js')
        ?.remove();
    classDeclaration.getConstructors()[0]?.remove();
    classDeclaration.getStaticMethod('getAttributeTypeMap')?.remove();
    classDeclaration.getStaticMember('discriminator')?.remove();
    classDeclaration.getStaticMember('mapping')?.remove();
    classDeclaration.getStaticMember('attributeTypeMap')?.remove();
    classDeclaration.getProperty('status')?.remove();
}

function removeAutogeneratedComments(sourceFile: SourceFile) {
    const start = sourceFile.getChildAtIndex(0).getLeadingCommentRanges()[0].getPos();
    const end = sourceFile.getChildAtIndex(0).getLeadingCommentRanges()[0].getEnd();
    sourceFile.replaceText([start, end], '');
}

function replaceRefs(sourceFile: SourceFile) {
    const t = sourceFile.getTypeAlias(sourceFile.getBaseNameWithoutExtension());
    t?.findReferencesAsNodes().forEach((node) => {
        const typeRef = node.getFirstAncestorByKind(SyntaxKind.TypeReference);
        if (typeRef) {
            log(
                `Replacing ${pc.gray(typeRef.getText())} in ${pc.cyan(typeRef.getSourceFile().getBaseName())} with ${pc.yellowBright('number | string')}`,
            );
            typeRef.replaceWithText('number | string');
        }
    });
    sourceFile.delete();
}

function replaceNumberStringTypes(project: Project, modelsPath: string) {
    const quantityFile = project.getSourceFile(
        path.join(modelsPath, 'IoK8sApimachineryPkgApiResourceQuantity.ts'),
    );
    const intOrStringFile = project.getSourceFile(
        path.join(modelsPath, 'IoK8sApimachineryPkgUtilIntstrIntOrString.ts'),
    );

    if (quantityFile) {
        replaceRefs(quantityFile);
    }

    if (intOrStringFile) {
        replaceRefs(intOrStringFile);
    }
}

function main() {
    const corePath = path.join(import.meta.dirname, '../../core');
    const modelsPath = path.join(corePath, 'src/models');
    removeUnusedFiles(modelsPath);
    /**
     * Format code to get rid of the quotes around the keys
     * so it's easier to work with ts-morph.
     */
    formatCode(modelsPath);

    const project = new Project({
        tsConfigFilePath: path.join(corePath, 'tsconfig.json'),
        manipulationSettings: {
            indentationText: IndentationText.TwoSpaces,
            quoteKind: QuoteKind.Double,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,
            useTrailingCommas: true,
        },
    });
    replaceNumberStringTypes(project, modelsPath);

    const schemas: Schemas = JSON.parse(
        fs.readFileSync(path.join(import.meta.dirname, '../schemas.json'), 'utf-8'),
    );

    for (const sourceFile of project.getSourceFiles()) {
        /**
         * Only process files in the src/models directory.
         */
        if (sourceFile.getDirectoryPath().startsWith(modelsPath)) {
            removeAutogeneratedComments(sourceFile);
            /**
             * openapi-generator generates one class per file.
             */
            const classDeclaration = sourceFile.getClasses()[0];
            const className = classDeclaration?.getName();
            if (className) {
                removeUnusedThings(sourceFile, classDeclaration, className);
                log(`Processing ${pc.cyan(sourceFile.getBaseName())}`);
                if (schemas.classes[className]) {
                    const apiVersionProperty = classDeclaration.getProperty('apiVersion');
                    if (apiVersionProperty) {
                        const group = schemas.classes[className].group;
                        const version = schemas.classes[className].version;
                        const groupVersion = group ? `${group}/${version}` : version;
                        apiVersionProperty.setInitializer(`'${groupVersion}'`);
                        apiVersionProperty.removeType();
                        apiVersionProperty.setIsReadonly(true);
                        apiVersionProperty.setHasQuestionToken(false);
                    }

                    const kindProperty = classDeclaration.getProperty('kind');
                    if (kindProperty) {
                        kindProperty.setInitializer(`'${schemas.classes[className].kind}'`);
                        kindProperty.removeType();
                        kindProperty.setIsReadonly(true);
                        kindProperty.setHasQuestionToken(false);
                    }

                    sourceFile.addImportDeclaration({
                        moduleSpecifier: '../K8sApp.js',
                        namedImports: ['K8sApp'],
                    });

                    const interfaceProps: PropertySignatureStructure[] = [];

                    const i: InterfaceDeclarationStructure = {
                        kind: StructureKind.Interface,
                        name: `${schemas.classes[className].kind}Args`,
                        isExported: true,
                        properties: interfaceProps,
                    };

                    const c: ConstructorDeclarationStructure = {
                        kind: StructureKind.Constructor,
                        parameters: [
                            {
                                name: 'app',
                                type: 'K8sApp',
                            },
                            {
                                name: 'name',
                                type: 'string',
                            },
                            {
                                name: 'args',
                                type: `${schemas.classes[className].kind}Args`,
                            },
                        ],
                    };

                    const preferredOrder = ['apiVersion', 'kind', 'metadata', 'spec'];
                    const orderedProps = classDeclaration.getProperties().sort((a, b) => {
                        const aIndex = preferredOrder.indexOf(a.getName());
                        const bIndex = preferredOrder.indexOf(b.getName());
                        if (aIndex === -1 && bIndex === -1) return 0;
                        if (aIndex === -1) return 1;
                        if (bIndex === -1) return -1;
                        return aIndex - bIndex;
                    });

                    c.statements = new Array<StatementStructures>();
                    c.statements.push('super(args.metadata?.name || name);');
                    for (const [i, prop] of orderedProps.entries()) {
                        prop.setIsReadonly(true);
                        classDeclaration.getProperty(prop.getName())?.setOrder(i);
                        const interfaceProp: PropertySignatureStructure = {
                            kind: StructureKind.PropertySignature,
                            name: prop.getName(),
                            type: prop.getTypeNode()?.getText(),
                            hasQuestionToken: prop.hasQuestionToken(),
                            isReadonly: true,
                        };
                        if (prop.getName() === 'apiVersion' || prop.getName() === 'kind') {
                            continue;
                        }
                        if (prop.getName() === 'metadata') {
                            interfaceProp.hasQuestionToken = true;
                            c.statements.push('this.metadata = {');
                            c.statements.push('  name: args.metadata?.name || name,');
                            c.statements.push('  ...args.metadata,');
                            c.statements.push('};');
                            prop.setHasQuestionToken(false);
                            if (schemas.classes[className].namespaced) {
                                classDeclaration.setExtends('NamespacedApiObject');
                                prop.setType('NamespacedObjectMeta');
                                sourceFile.addImportDeclaration({
                                    moduleSpecifier: '../ApiObject.js',
                                    namedImports: ['NamespacedObjectMeta', 'NamespacedApiObject'],
                                });
                                interfaceProp.type = 'NamespacedObjectMeta';
                                sourceFile
                                    .getImportDeclaration(
                                        '../models/IoK8sApimachineryPkgApisMetaV1ObjectMeta.js',
                                    )
                                    ?.remove();
                            } else {
                                classDeclaration.setExtends('ApiObject');
                                sourceFile.addImportDeclaration({
                                    moduleSpecifier: '../ApiObject.js',
                                    namedImports: ['ApiObject'],
                                });
                                interfaceProp.type = 'ObjectMeta';
                            }
                        } else {
                            c.statements.push(`this.${prop.getName()} = args.${prop.getName()};`);
                        }
                        interfaceProps.push(interfaceProp);
                    }
                    sourceFile.insertInterface(classDeclaration.getChildIndex(), i);
                    c.statements.push('app.addResource(this);');
                    classDeclaration.addConstructor(c);
                    classDeclaration.rename(schemas.classes[className].kind);
                } else {
                    if (className === 'IoK8sApimachineryPkgApisMetaV1ObjectMeta') {
                        classDeclaration.getProperty('namespace')?.remove();
                        classDeclaration.getProperty('creationTimestamp')?.remove();
                        classDeclaration.getProperty('deletionGracePeriodSeconds')?.remove();
                        classDeclaration.getProperty('deletionTimestamp')?.remove();
                        classDeclaration.getProperty('generation')?.remove();
                        classDeclaration.getProperty('resourceVersion')?.remove();
                        classDeclaration.getProperty('uid')?.remove();
                        classDeclaration.getProperty('selfLink')?.remove();
                    }
                    classDeclaration.rename(schemas.interfaces[className].kind);

                    const i: InterfaceDeclarationStructure = {
                        kind: StructureKind.Interface,
                        name: schemas.interfaces[className].kind,
                        isExported: true,
                        docs: [
                            {
                                kind: StructureKind.JSDoc,
                                description: `\n${classDeclaration
                                    .getJsDocs()
                                    .map((doc) => doc.getInnerText())}`,
                            },
                        ],
                        properties: classDeclaration.getProperties().map((prop) => {
                            return {
                                name: prop.getName(),
                                type: prop.getTypeNode()?.getText(),
                                hasQuestionToken: prop.hasQuestionToken(),
                                isReadonly: prop.isReadonly(),
                                docs: [
                                    {
                                        kind: StructureKind.JSDoc,
                                        description: `\n${prop.getJsDocs().map((doc) => {
                                            return doc.getInnerText();
                                        })}`,
                                    },
                                ],
                            };
                        }),
                    };

                    classDeclaration.remove();
                    sourceFile.addInterface(i);
                }

                sourceFile.getImportDeclarations().forEach((importDeclaration) => {
                    const updatedImport = importDeclaration
                        .getModuleSpecifierValue()
                        .replace('./models', '');
                    importDeclaration.setModuleSpecifier(updatedImport);
                });
            }
        }
    }

    project.saveSync();
    formatCode(modelsPath);
}

main();
